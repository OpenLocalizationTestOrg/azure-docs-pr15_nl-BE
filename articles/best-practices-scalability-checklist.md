<properties
   pageTitle="Controlelijst voor schaalbaarheid | Microsoft Azure"
   description="Schaalbaarheid controlelijst richtlijnen voor ontwerp zorgen voor Azure Autoscaling."
   services=""
   documentationCenter="na"
   authors="dragon119"
   manager="christb"
   editor=""
   tags=""/>

<tags
   ms.service="best-practice"
   ms.devlang="na"
   ms.topic="article"
   ms.tgt_pltfrm="na"
   ms.workload="na"
   ms.date="07/13/2016"
   ms.author="masashin"/>

# <a name="scalability-checklist"></a>Controlelijst voor schaalbaarheid

[AZURE.INCLUDE [pnp-header](../includes/guidance-pnp-header-include.md)]

## <a name="service-design"></a>Ontwerp service
- **Partitie van de werkbelasting**. Onderdelen van het proces worden afzonderlijke en decomposable ontwerpen. De grootte van elk deel, terwijl het volgens de gebruikelijke regels voor scheiding van problemen en het beginsel van één minimaliseren. Hierdoor kunnen de onderdelen moeten worden gedistribueerd op een manier die het gebruik van elke compute eenheid (bijvoorbeeld een rol of database server) wordt gemaximaliseerd. Het ook gemakkelijker om de toepassing te schalen door sessies van specifieke bronnen toe te voegen. Zie voor meer informatie, [Richtlijnen voor partitionering berekenen](https://msdn.microsoft.com/library/dn589773.aspx).
- **Ontwerp voor schalen**. Schalen in staat stelt te reageren op variabele laden door te verhogen en verlagen van het aantal exemplaren van rollen, wachtrijen en andere diensten die ze gebruiken. De toepassing moet echter worden ontworpen met dit in gedachten. Bijvoorbeeld, moet de toepassing en de services die wordt gebruikt stateless ', zodat aanvragen worden doorgestuurd naar een exemplaar. Dit voorkomt ook dat de toevoeging of verwijdering van specifieke exemplaren huidige gebruikers nadelig beïnvloeden. U moet ook implementeren configuratie of automatische detectie van instanties zoals ze zijn toegevoegd en verwijderd, zodat de code in het programma de nodige routering kan uitvoeren. Een webtoepassing kan een set van wachtrijen bijvoorbeeld gebruiken in een round robin aanpak aanvragen doorsturen naar Achtergrondservices die worden uitgevoerd in de rollen van de werknemer. De webtoepassing moet kunnen wijzigingen worden gedetecteerd in het aantal wachtrijen voor het doorsturen van aanvragen en de belasting over de toepassing.
- **Schaal als een eenheid**. Planning voor aanvullende bronnen voor groei. Voor elke resource en de bovenste schaal grenzen kent en sharding of ontbinding verder te gaan dan deze limieten. De schaaleenheden voor het systeem in termen van goed gedefinieerde sets van bronnen bepalen. Hierdoor toepassen schalen bewerkingen eenvoudiger en minder gevoelig voor de negatieve gevolgen van de toepassing tot en met beperkingen door gebrek aan bronnen in een deel van het algehele systeem. Bijvoorbeeld, toe te voegen x aantal web en werknemer mogelijk aantal aanvullende wachtrijen y en z-nummer van de rekeningen van de opslag voor het verwerken van het extra werk gegenereerd door de rollen. Dus een schaaleenheid kan bestaan uit x web en werknemer rollen, wachtrijen _y_ en _z_ opslag rekeningen. De toepassing zodanig ontwerpen dat deze gemakkelijk door het toevoegen van een of meer schaaleenheden wordt geschaald.
- **Voorkom clientaffiniteit**. Waar mogelijk, ervoor te zorgen dat er geen affiniteit is vereist voor de toepassing. Aanvragen kunnen dus worden doorgestuurd naar een willekeurig exemplaar en het aantal exemplaren is niet relevant. Zo voorkomt u ook de overhead van opslaan, ophalen en beheren van informatie over de status van elke gebruiker.
- **Platform autoscaling functies benutten**. Indien de host-platform een mogelijkheid autoscaling ondersteunt zoals Azure automatisch schalen, liever deze mechanismen voor aangepaste of derden tenzij ingebouwd mechanisme kan niet aan uw eisen voldoen. Regels voor geplande schaal gebruiken waar mogelijk resources zijn onverwijld opstarten maar reactieve autoscaling toevoegen aan de regels in voorkomend geval omgaan met onverwachte wijzigingen in de vraag. Autoscaling aanpassen en de aangepaste items toevoegen aan de regels, kunt u de bewerkingen autoscaling in de Management Service API. Zie [richtlijnen voor automatische schaling](best-practices-auto-scaling.md)voor meer informatie.
- **Offload-intensieve CPU/i/o-taken als achtergrondtaken**. Als een aanvraag naar een service wordt verwacht dat lang duren of aanzienlijke middelen te absorberen, ontlasten van de verwerking van deze aanvraag aan een afzonderlijke taak. Werknemer rollen of achtergrondtaken (afhankelijk van de host-platform) gebruiken voor het uitvoeren van deze taken. Deze strategie kan de service blijven verdere aanvragen ontvangen en blijven reageren.  Zie [richtlijnen voor achtergrond taken](best-practices-background-jobs.md)voor meer informatie.
- **De werkbelasting voor de achtergrondtaken verdelen**. Wanneer er veel achtergrondtaken of taken vereisen veel tijd of resources, verdeeld over het werk meerdere compute eenheden (bijvoorbeeld werknemer-functies of achtergrondtaken). Zie het [Patroon van concurrerende consumenten](https://msdn.microsoft.com/library/dn568101.aspx)voor een mogelijke oplossing.
- **Overweeg verplaatsen naar een _gedeelde niets_ architectuur**. Een gedeelde architectuur maakt gebruik van onafhankelijke, vergaderverzoeken verwerken knooppunten met geen enkel punt van een conflict (bijvoorbeeld gedeelde services of opslag). In theorie kan een dergelijk systeem bijna voor onbepaalde tijd schalen. Terwijl een volledig gedeelde-aanpak meestal niet praktisch voor de meeste toepassingen is, kan deze bieden mogelijkheden voor een betere schaalbaarheid ontwerpen. Bijvoorbeeld voor het vermijden van het gebruik van server-side sessiestatus clientaffiniteit en partitioneren van gegevens zijn goede voorbeelden van te verplaatsen naar een gedeelde architectuur.

## <a name="data-management"></a>Gegevensbeheer

- **Gebruik gegevens partitioneren**. De gegevens verdelen over meerdere databases en databaseservers of ontwerp voor opslag van gegevens die services bieden deze partitioneren transparant (voorbeelden zijn Azure SQL Database elastische Database en tabel Azure opslag). Deze benadering kunt u prestaties maximaliseren en kunnen gemakkelijker aanpassen. Er zijn verschillende technieken, zoals horizontaal, verticaal, partitioneren en functioneel. U kunt een combinatie van deze bereiken kan profiteren van betere prestaties, schaalbaarheid eenvoudiger, flexibeler beheer, betere beschikbaarheid en overeenkomen met het type archief tot de gegevens mogelijk is. Ook overwegen om verschillende soorten gegevensarchief voor verschillende soorten gegevens, kiest de typen op basis van hoe goed ze zijn geoptimaliseerd voor het specifieke type van de gegevens. Dit kan ook met behulp van tabelopslag, de database van een document of een kolom familie gegevensarchief, in plaats van, of zo goed als een relationele database. Zie voor meer informatie, [richtlijnen voor partitionering van gegevens](best-practices-data-partitioning.md).
- **Ontwerp voor het uiteindelijke algehele consistentie**. Uiteindelijke algehele consistentie verbetert de schaalbaarheid door de vermindering of het verwijderen van de tijd die nodig is om verwante gegevens gepartitioneerd in meerdere winkels te synchroniseren. De kostprijs is dat gegevens is niet altijd consistent als sommige bewerkingen kunnen conflicten veroorzaken schrijven en lezen is. Uiteindelijke algehele consistentie is ideaal in situaties waar dezelfde gegevens lezen vaak maar weinig geschreven. Zie voor meer informatie de [Gegevens consistent Primer](https://msdn.microsoft.com/library/dn589800.aspx).
- **Verminderen chatty interacties tussen onderdelen en -services**. Ontwerpen van interacties waarin een toepassing nodig is om meerdere aanroepen naar een service voorkomen (die resulteert in een kleine hoeveelheid gegevens), in plaats van een enkele aanroep die alle gegevens kan retourneren. Indien mogelijk combineren verschillende gerelateerde bewerkingen in een enkele aanvraag wanneer de oproep is een service of het onderdeel dat merkbare vertraging heeft. Dit vereenvoudigt prestaties bewaken en optimaliseren van complexe bewerkingen. Bijvoorbeeld gebruik van opgeslagen procedures in databases voor het inkapselen van complexe logica en verminder het aantal retouren en vergrendelen van de resource.
- **Met de wachtrijen om het niveau van de belasting voor hoge snelheid gegevens schrijft**. Piekspanningen vraag naar een service kunnen overstelpen service en de almaar toenemende fouten veroorzaken. Om dit te voorkomen, kunt u uitvoering van het [laden bij het herverdelen patroon op basis van wachtrijen](https://msdn.microsoft.com/library/dn589783.aspx). Gebruik een wachtrij die fungeert als buffer tussen een taak en een service die deze activeert. Dit kan af en toe zware belasting die ertoe leiden dat kunnen de service of de taak time-out vloeiend.
- **Minimaliseren de belasting van het gegevensarchief**. Het gegevensarchief is doorgaans een knelpunt verwerking, een kostbare bron en vaak niet gemakkelijk schaalt. Waar mogelijk, logica (zoals het verwerken van XML-documenten of objecten JSON) verwijderen uit het gegevensarchief en verwerking in de toepassing uitvoeren. Bijvoorbeeld, in plaats van XML naar de database (andere dan als één tekenreeks voor opslag), serialiseren of terugconverteren van de XML-gegevens in de toepassingslaag en doorgeven in een vorm die bij de data store. Het is meestal veel eenvoudiger voor het schalen van de toepassing dan de data store, zodat u proberen beter te doen zo veel mogelijk van de intensieve verwerking mogelijk binnen de toepassing.
- **Minimaliseren van het volume van de gegevens worden opgehaald**. Alleen de gegevens die u nodig hebt door het opgeven van kolommen en rijen selecteren met behulp van criteria halen. Maak gebruik van de parameters voor waarde en het gewenste isolatieniveau. Gebruik mechanismen zoals eenheidtags om te voorkomen dat onnodig ophalen van gegevens.
- **Serieus gebruik maken van caching**. Gebruik zoveel mogelijk te verminderen, de belasting van bronnen en services die zijn gegenereerd of gegevens te leveren in de cache opslaan. Caching is doorgaans geschikt voor de gegevens tamelijk statisch is of waarvoor aanzienlijke verwerking te verkrijgen. Opslaan in de cache moet worden uitgevoerd op alle niveaus in voorkomend geval in elke laag van de toepassing, met inbegrip van data access en gebruiker interface genereren. Zie de [Instructies in de cache opslaan](best-practices-caching.md)voor meer informatie.
- **Verwerken van, Gegevensgroei en het vasthouden van**. De hoeveelheid gegevens die zijn opgeslagen door een toepassing wordt na verloop van tijd groter. Deze groei neemt de kosten voor opslag en verhoogt de wachttijd bij de toegang tot de gegevens, die van invloed is op toepassing doorvoer en prestaties. Het mogelijk periodiek archiveren sommige oude gegevens die niet langer toegankelijk is, of verplaatsen van gegevens die zelden wordt geopend in de opslag voor langere termijn die rendabeler, zelfs als de latentie is hoger.
- **Optimaliseren gegevens overbrengen objecten (DTOs) met behulp van een efficiënte binaire indeling**. DTOs worden doorgegeven tussen de lagen van een toepassing meerdere malen. De grootte te minimaliseren, wordt de belasting van bronnen en het netwerk. Echter het saldo van de besparingen die met de overhead van de gegevens te converteren naar de juiste opmaak op elke locatie waar het wordt gebruikt. Vast in een indeling die de maximale interoperabiliteit inschakelen eenvoudig hergebruik van een onderdeel is.
- **Cache-besturingselement ingesteld**. Ontwerp en de toepassing configureren voor gebruik uitvoercaching of caching, indien mogelijk, tot een minimum beperken verwerkingsbelasting fragmenteren.
- **Caching aan clientzijde inschakelen**. Webtoepassingen Schakel cache-instellingen voor de inhoud die in de cache kunnen worden opgeslagen. Dit is meestal standaard uitgeschakeld. Configureer de server voor het leveren van de juiste cache om te schakelen van de inhoud op de proxyservers en clients in de cache-control-headers.
- **Gebruik Azure blob-opslag en Azure Content Delivery Network ter vermindering van de belasting van de toepassing**. Kunt u statische of tamelijk statisch openbare inhoud, zoals afbeeldingen, resources, scripts en opmaakmodellen, op te slaan in de blob-opslag. Deze methode brengt de toepassing van de belasting veroorzaakt door het dynamisch genereren van deze inhoud voor elke aanvraag. Let op het gebruik van het netwerk van de levering inhoud deze inhoud in de cache en bezorgt het aan clients. Via het netwerk van de levering inhoud kunt verbeteren op de client omdat de inhoud van het geografisch meest datacenter met een cache-inhoud Delivery Network is afgeleverd. Zie voor meer informatie de [Content Delivery Network richtlijnen](best-practices-cdn.md).
- **Optimaliseren en tune SQL-query's en indexen**. Sommige T-SQL-instructies of constructies kunnen gevolgen hebben op de prestaties die kan worden verminderd door het optimaliseren van de code in een opgeslagen procedure. Vermijd bijvoorbeeld **datum/tijd** typen converteren naar een **varchar** vóór te vergelijken met een letterlijke **datum/tijd** -waarde. Functies voor datum/tijd-vergelijking te gebruiken. Ontbreken van de juiste indexen kan vertragend uitvoering van de query. Als u een object relationele kader voor de toewijzing, begrijpen hoe het werkt en hoe heeft dit invloed op de prestaties van de data access-laag. Zie [Query afstemmen](https://technet.microsoft.com/library/ms176005.aspx)voor meer informatie.
- **Overweeg de normalisatie van gegevens**. Gegevensnormalisatie kunt kopiëren en inconsistentie te voorkomen. Legt een overhead die invloed kan hebben op de prestaties echter meerdere indexen beheren voor referentiële integriteit controleren, meerdere toegangen tot de kleine stukken gegevens uitvoeren en koppelen van tabellen om het opnieuw samenstellen van de gegevens. Overweeg als sommige extra opslagvolume en dubbel werk ter vermindering van de belasting van de data store aanvaardbaar is. Bedenk ook als de toepassing zelf (dit is meestal gemakkelijker te schalen) kan worden tegengeworpen, over taken zoals het beheren van referentiële integriteit ter vermindering van de belasting van de gegevensopslag te nemen. Zie voor meer informatie, [richtlijnen voor partitionering van gegevens](https://github.com/mspnp/azure-guidance/blob/master/Data%20partitioning.md).

## <a name="service-implementation"></a>Service-implementatie
- **Asynchrone aanroepen gebruiken**. Asynchrone code waar mogelijk gebruikt als toegang tot bronnen of services die kunnen worden beperkt door het i/o-bandbreedte van het netwerk en/of die een merkbare vertraging om te voorkomen dat het vergrendelen van de thread. Gebruik voor het implementeren van asynchrone bewerkingen, [Taakgerichte asynchrone patroon (tik)](https://msdn.microsoft.com/library/hh873175.aspx).
- **Wellicht niet de enige bronnen, en een optimistische benadering te gebruiken**. Nooit lock toegang tot bronnen zoals opslag of andere services die merkbaar latentie, zijn omdat dit een primaire oorzaak van slechte prestaties. Gebruik altijd de optimistische aanpak voor het beheren van gelijktijdige bewerkingen, zoals het schrijven naar de opslag. Functies van de opslaglaag gebruiken voor het beheer van conflicten. In een gedistribueerde toepassingen kunnen gegevens worden alleen uiteindelijk consistent.
- **Gegevenscompressie sterk gecomprimeerd over lange wachttijden, netwerken met lage bandbreedte**. De grootste hoeveelheid gegevens gegenereerd door de toepassing en doorgegeven via het netwerk is in de meeste gevallen in een webtoepassing HTTP-antwoorden op aanvragen van clients. HTTP-compressie kunt verminderen hierdoor aanzienlijk, vooral voor statische inhoud. Dit vermindert kosten, alsmede een vermindering van de belasting van het netwerk, maar dynamische inhoud is een fractie hogere belasting van toepassing op de server. In andere, meer algemene omgevingen, compressie van gegevens vermindert het volume van verzonden gegevens en transfertijd en kosten te minimaliseren, maar de processen voor compressie en decompressie overhead oplopen. Compressie moet als zodanig alleen worden gebruikt wanneer er een aantoonbare toename in prestaties. Andere methoden serialisatie, zoals JSON of binaire codes kunnen verkleinen payload tijdens die minder invloed op de prestaties, dat XML dreigt te verhogen.
- **Minimaliseren van de tijd die verbindingen en bronnen gebruikt worden**. Verbindingen en bronnen alleen behouden als u ze nodig hebt. Zo laat mogelijk verbindingen te openen en kunnen ze worden teruggestuurd naar de groep zo spoedig mogelijk. Zo laat mogelijk middelen verwerven en vervreemden en deze zo spoedig mogelijk.
- **Minimaliseren van het aantal verbindingen vereist**. Serviceverbindingen absorberen bronnen. Het nummer dat vereist zijn en ervoor te zorgen dat de bestaande verbindingen worden hergebruikt zoveel mogelijk beperken. Bijvoorbeeld na het uitvoeren van verificatie gebruikmaken van imitatie eventueel code uit te voeren als een bepaalde identiteit. Dit kan bijdragen aan het beste gebruik maken van de groep door het hergebruik van verbindingen.

    > [AZURE.NOTE]: APIs for some services automatically reuse connections, provided service-specific guidelines are followed. It's important that you understand the conditions that enable connection reuse for each service that your application uses.

- **Aanvragen in batches netwerk optimaliseren**. Bijvoorbeeld verzenden en lezen van berichten in batches bij toegang tot een wachtrij en meerdere lees- of schrijfbewerkingen als batch uitgevoerd wanneer toegang tot opslag of een cache. Dit kan bijdragen aan het optimaliseren van de services en gegevens winkels door vermindering van het aantal oproepen via het netwerk.
- **Neem nooit een vereiste voor het opslaan van server-side sessiestatus** waar mogelijk. Server-side sessiebeheer staat meestal vereist clientaffiniteit (dat is, elke aanvraag routering op dezelfde serverinstantie), die van invloed op de mogelijkheid van het systeem uit te breiden. In het ideale geval moet u de clients geen status met betrekking tot de servers die ze gebruiken ontwerpen. Als de toepassing moet sessiestatus bijhoudt, gevoelige gegevens op te slaan of grote hoeveelheden gegevens in een gedistribueerde serverzijde per client in de cache die kunnen alle exemplaren van de toepassing benaderen.
- **De tabelschema opslag optimaliseren**. Wanneer u de tabel bevat waarvoor u de tabel- en kolomnamen worden doorgegeven en verwerkt met elke query, zoals tabelopslag, Azure, kunt u overwegen kortere namen deze overhead te verminderen. Echter niet ten koste van leesbaarheid en beheer met behulp van zeer compacte namen.
- **Gebruik de taak parallelle bibliotheek (TPL) asynchrone bewerkingen uit te voeren**. De TPL gemakkelijk asynchrone code schrijven die I/O-bewerkingen worden uitgevoerd. Gebruik _ConfigureAwait(false)_ zoveel mogelijk te elimineren, de afhankelijkheid van een voortzetting van een bepaalde context. Dit verkleint de kans op een thread deadlock optreedt.
- **Bronafhankelijkheden maken tijdens de implementatie of bij het opstarten van de toepassing**. Vermijd het herhaaldelijk aanroepen van methoden voor het testen van het bestaan van een resource en maak vervolgens de resource als deze nog niet bestaat. (Methoden zoals _CloudTable.CreateIfNotExists_ en _CloudQueue.CreateIfNotExists_ in de bibliotheek Azure opslag Client Volg dit patroon). Deze methoden kunnen aanzienlijke belasting opleggen als ze worden aangeroepen vóór elke toegang tot een tabel voor opslag of opslag wachtrij. In plaats daarvan:
 - De vereiste bronnen maken wanneer de toepassing wordt geïmplementeerd, of het starten (één aanroep _CreateIfNotExists_ voor elke resource in de opstartcode voor de rol van een web- of werknemer is acceptabel). Echter, moet u uitzonderingen die kunnen ontstaan als uw code probeert toegang te krijgen tot een bron die niet bestaat. In deze gevallen moet u de uitzondering zich en mogelijk een waarschuwing een exploitant een bron ontbreekt.
 - Onder bepaalde omstandigheden kan het dienstig zijn de ontbrekende bron maken als onderdeel van de code verwerking van uitzonderingen. Maar u dient vast te stellen deze aanpak voorzichtig als het niet bestaan van de resource voor een programmeerfout (verkeerd gespelde naam van een resource bijvoorbeeld) of een ander probleem op infrastructuur-niveau.
- **Gebruik lichte frameworks**. Kies zorgvuldig de API's en kaders met u te minimaliseren, Resourcegebruik, uitvoeringstijd en belasting van de toepassing. Bijvoorbeeld, Web-API gebruiken voor het verwerken van aanvragen voor de toepassing van kooldioxide vermindert en verhogen bewerkingssnelheid, maar niet zijn geschikt voor geavanceerde scenario's waarin de extra mogelijkheden van Windows Communication Foundation vereist zijn.
- **Overweeg het aantal serviceaccounts minimaliseren**. Gebruik bijvoorbeeld een specifieke account voor toegang tot bronnen of services die hebben een limiet van de verbindingen of uitvoeren beter waar minder verbindingen worden beheerd. Deze benadering is het gebruikelijk voor services, zoals databases, maar kan invloed hebben op de mogelijkheid om bewerkingen door de imitatie van de oorspronkelijke gebruiker nauwkeurig controleren.
- **Beoordeling van prestaties en load testen uitvoeren** tijdens de ontwikkeling, als onderdeel van de test routines en voordat de definitieve versie, zodat de toepassing uitvoert en schalen zoals vereist. Deze tests moet worden uitgevoerd op hetzelfde soort hardware als de productie platform en met dezelfde typen en hoeveelheden gegevens en de gebruiker geladen zoals het optreden van de productie. Zie [de prestaties van een cloud-service testen](vs-azure-tools-performance-profiling-cloud-services.md)voor meer informatie.
